<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-toast/paper-toast.html">
<link rel="import" href="../../bower_components/paper-header-panel/paper-header-panel.html">
<link rel="import" href="../../bower_components/paper-toolbar/paper-toolbar.html">

<dom-module id="game-of-life-field">
    <template>
        <style>
            :host {
                display: inline-block;
            }

            .container {
                display: inline-block;
                background-color: #808080;
            }

            .loading-block {
                height: 4px;
                background-color: #808080;
            }

            paper-progress {
                --paper-progress-active-color: var(--paper-yellow-500);
            }

        </style>

        <style is="custom-style">
            paper-header-panel {
                float: left;
                margin: 5px;
            }

            .green .paper-toolbar-0 {
                background-color: var(--paper-green-500);
            }

            .orange .paper-toolbar-0 {
                background-color: var(--paper-orange-500);
            }

            .blue .paper-toolbar-0 {
                background-color: var(--paper-blue-500);
            }

            .red .paper-toolbar-0 {
                background-color: var(--paper-red-500);
            }
        </style>

        <iron-ajax id="ajax" method="POST" content-type="text/plain" url="/service" handle-as="json"
                   loading="{{loading}}"
                   on-response="_onNextGenerations"
                   on-error="_onError"></iron-ajax>

        <paper-toast id="error"></paper-toast>


        <paper-header-panel class$="{{headerClass}}" mode="seamed">
            <paper-toolbar id="toolbar">
                <div>{{hostName}}</div>
            </paper-toolbar>
            <template is="dom-if" if="{{loading}}">
                <paper-progress indeterminate class="slow" style="width: 100%"></paper-progress>
            </template>
            <template is="dom-if" if="{{!loading}}">
                <div class="loading-block"></div>
            </template>
            <div id="container" class="container"></div>
        </paper-header-panel>

    </template>

    <script>
        Polymer({

            is: 'game-of-life-field',

            properties: {

                serviceId: {
                    type: String
                },

                hostName: {
                    type: String
                },

                cells: {
                    type: String,
                    observer: '_cellsChanged'
                },

                solution: {
                    type: Boolean,
                    value: false
                },

                cubeSize: {
                    type: Number,
                    value: 20
                },

                frames: {
                    type: Number,
                    value: 250
                },

                error: {
                    type: Boolean,
                    value: false
                },

                headerClass: {
                    type: String
                },

                loading: {
                    type: Boolean,
                    notify: true,
                    value: false
                },

                mode: {
                    type: String
                }
            },

            _cellsChanged: function() {
                for (var y in this.liveCubes) {
                    for (var x in this.liveCubes[y]) {
                        this._killCell([y, x]);
                    }
                }
                this.current = atob(this.cells);
                this.currentRight = this.current;
                this.next = [];
                this.nextRight = [];
                this._parseGeneration();
            },

            attached: function () {
                this._cellsChanged();
                this._buildScene();
                this._initializeCubes();
                this._cubesLoop(this)();
                this._animate(this)();
            },

            destroy: function () {

            },

            _parseGeneration: function () {
                this.generation = [];
                var array = this.current.split("\n");
                for (var i in array) {
                    this.generation[i] = array[i].trim().split("");
                }
                this.rows = this.generation.length;
                this.cols = this.generation[0].length;
            },

            _buildScene: function () {
                this.container = this.$.container;
                var w = this.cols * this.cubeSize;
                var h = this.rows * this.cubeSize;
                this.style.height = (h + 74) + 'px';

                this.scene = new THREE.Scene();

                // Camera.

                var z = Math.min(w, h);
                var fov = 2 * Math.atan(h / (2 * z));
                this.camera = new THREE.PerspectiveCamera(fov * 180 / Math.PI, w / h, 1, 10000);
                this.camera_x = 0;
                this.camera_y = 0;
                this.camera_z = z + this.cubeSize;
                this.cameraTarget = new THREE.Vector3(0, 0, 0);
                this.camera.position.y = this.camera_y;
                this.camera.position.z = this.camera_z;
                this.camera.position.x = this.camera_x;
                this.camera.lookAt(this.cameraTarget);

                this.scene.add(this.camera);

                // Plane.
                this.plane = new THREE.Mesh(
                        new THREE.PlaneGeometry(this.cols * this.cubeSize, this.rows * this.cubeSize, this.cols, this.rows),
                        new THREE.MeshBasicMaterial({ color: 0x999999, wireframe: true }));

                this.plane.rotation.x = Math.PI / 2;

                this.scene.add(this.plane);

                // Renderer.
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(w, h);
                this.container.appendChild(this.renderer.domElement);
            },

            _initializeCubes: function () {
                this.cubeGeo = new THREE.CubeGeometry(this.cubeSize, this.cubeSize, this.cubeSize);
                this.cubeMaterial = new THREE.MeshBasicMaterial({
                    shading: THREE.FlatShading,
                    map: THREE.ImageUtils.loadTexture("/images/square-outline.png")
                });
                this.cubeMaterial.color.setHex(0xffff00);
                this.cubeMaterial.ambient = this.cubeMaterial.color;
                this.cubesPool = [];
                this.liveCubes = this._matrix(this.rows, this.cols);
            },

            _buildCube: function () {
                var cube = new THREE.Mesh(this.cubeGeo, this.cubeMaterial);
                cube.visible = false;
                this.scene.add(cube);
                return cube;
            },

            _matrix: function (rows, columns) {
                var grid = new Array(rows);
                for (var i = 0; i < rows; i++) {
                    grid[i] = new Array(columns);
                }
                return grid;
            },

            _cubesLoop: function (self) {
                return function () {
                    for (var y in self.generation) {
                        for (var x in self.generation[y]) {
                            switch (self.generation[y][x]) {
                                case ".":
                                    self._killCell([y, x]);
                                    break;
                                case "O":
                                    self._drawCell([y, x]);
                                    break;
                            }
                        }
                    }
                    if (self.next.length < self.frames / 2 && !self.$.ajax.loading) {
                        self.$.ajax.url = "/service/" + (self.serviceId !== undefined ? btoa(self.serviceId) : "");
                        self.$.ajax.body = self.nextRight.length === 0 ? self.currentRight : self.nextRight[self.next.length - 1];
                        self.$.ajax.params = { frames: self.frames, mode: self.mode };
                        self.$.ajax.generateRequest();
                    }
                    if (self.next.length > 0) {
                        self.current = self.next.shift();
                        self.currentRight = self.nextRight.shift();
                        self.headerClass = self.solution ? "green" : (self.current === self.currentRight ? "blue" : "orange");
                        self._parseGeneration();
                    }
                    setTimeout(self._cubesLoop(self), self.error ? 5000 : 100);
                };
            },

            _animate: function (self) {
                return function () {
                    requestAnimationFrame(self._animate(self));
                    self._render();
                };

            },

            _render: function () {
                this.renderer.render(this.scene, this.camera);
            },

            _getCube: function () {
                return this.cubesPool.shift() || this._buildCube();
            },

            _drawCell: function (coords) {
                var cube = this.liveCubes[coords[0]][coords[1]];
                if (cube === undefined) {
                    cube = this._getCube();
                    cube.position.x = (coords[1] - this.cols / 2) * this.cubeSize + this.cubeSize / 2;
                    cube.position.y = (this.rows / 2 - coords[0]) * this.cubeSize - this.cubeSize / 2;
                    cube.position.z = 10;
                    cube.visible = true;
                    this.liveCubes[coords[0]][coords[1]] = cube;
                }
            },

            _killCell: function (coords) {
                var cube = this.liveCubes[coords[0]][coords[1]];
                if (cube !== undefined) {
                    cube.visible = false;
                    this.liveCubes[coords[0]][coords[1]] = undefined;
                    this.cubesPool.push(cube);
                }
            },

            _onNextGenerations: function (e, data) {
                var response = data.xhr.response;
                if (response.error == true) {
                    this.error = true;
                    this.headerClass = "red";
                } else {
                    for (var i in response.computed) {
                        this.next.push(response.computed[i]);
                        this.nextRight.push(response.right[i]);
                    }
                    this.error = false;
                }
            },

            _onError: function () {
                this.error = true;
                this.headerClass = "red";
            }


        });
    </script>
</dom-module>
